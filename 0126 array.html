<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 배열 !!! array </title>
</head>
<body>
    

 <script>
   //배열은 자료구조이다 그럼 object는 뭐야 ? 
   //object는 서로 연관된 특징과 행동을 묶어 놓은 것 예를 들어 토끼 - 긴귀2 분홍코 먹는다 뛴다 =object 
   //배열 = 자료구조는 토끼1 토끼2 토끼3 ... 를 바구니에 담는 것 

   //다른 언어에서는 data type도 같아야하나 javascript는 dynamically typed language로 동적으로 타입이 결정되는 언어라서 타입이 없이 한 바구니안에 다양한 종류의 데이터를 담을 수 있음 (그러나 좋지 않다 )

    //배열은 ()()()()() 텅텅빈 박스가 있고 번호가 0,1,2,3,4 이렇게 붙여져 있는 것과 같다  >> 자료를 넣으면 박스가 채워지는 것과 같다 

    'use strict';
    //Array
    //1. 선언 Declaration

    const arr1 = new Array();
    const arr2 = [1,2];

    //2. Index position
    const fruits = ['apple', 'banana'];
    console.log(fruits);
    console.log(fruits.length); //배열의 길이는 2
    console.log(fruits[0]); 
    //마지막을 찾는법
    console.log(fruits[fruits.length-1]); //인덱스번호는 0부터시작하므로

    //3. 모든 배열값 나열하기 
    for(let i=0; i<fruits.length; i++){
        console.log(fruits[i]);
    } //for loop i가 0부터 시작해서 총길이 이전(i<2)까지 0++1이 출력 

    //모든 배열값 나열하기 for of사용 
    //let 단수 of 복수 
    for (let fruit of fruits) {
        console.log(fruit);
    }

    //forEach사용 array에 들어있는 각 element요소 마다 액션을 수행 forEach(파라미터1 콜백함수 전달 우리가 전달한 함수를 밸류 하나하나마다 호출해줌(콜백함수에는 인자가 3개 있는데 밸류/인덱스/배열) 파라미터2 전달해도 되고 안해줘도 됨 )
    fruits.forEach(function(fruit, index, array){
        console.log(fruit, index, array);
    });
    fruits.forEach((fruit) => console.log(fruit));
    //foreach는 배열안에 들어있는 value들마다 내가 전달한 함수를 출력하는 구나 

    /**/
    //4 addtion deletion
    //push : add an item to the end
    fruits.push('strowberry','peach');
    console.log(fruits); //맨뒤에 데이터 추가 
    //pop : remove an item from the end
    fruits.pop(); //맨뒤에 데이터 사라짐 'peach'사라짐
    fruits.pop(); //맨뒤에 데이터 사라짐 'strowberry' 사라짐
    console.log(fruits);

    //앞에서 추가하는 unshift : add an item to beginning
    fruits.unshift('lemon');
    console.log(fruits);

    //앞에서 제거하는 shift 
    
    fruits.shift();
    console.log(fruits);

    //note >>>>>>> shift와 unshift는 pop&push보다 훨~~씬 느려요
    
    //배열은 데이터박스가 ()()()()()나열된 형태인데 앞에서 데이터를 넣으려면 첫번째 데이터박스를 비우고 새롭게 넣기 위해서 1데이터>2박스, 2>3박스, 3>4박스 데이터 옮기는 작업이 수행됨 //배열의 길이가 길수록 더~~ 느려짐 
    //pop , push처럼 뒤에서 데이터를 움직이는 것은 빠르다 
    
    
    /**/
    //지정된 위치에서 지우거나 아이템을 추가하는 것 : splice

    fruits.push('berry', 'peach');
    console.log(fruits);
    //fruits.splice(1);//인덱스번호1부터 뒤에 싹 다 지워짐
    //console.log(fruits); //인덱스번호1부터 뒤에 싹 다 지워짐
    fruits.splice(1,1);
    console.log(fruits); //인덱스번호1위치에서1아이템만 지운다 즉 인덱스번호1의 아이템만 지워짐 

    //중간에 다른아이템을 추가하려면 
    fruits.splice(1,1,'greenapple','grape');
    console.log(fruits); //인덱스번호1의자리에있던'berry'가 사라지고 아이템 2개가 추가로 들어갔음 
    //사라지지 않게 하려면 (indexNumber, 0, 'new1', 'new2 ') 이렇게 쓰면 됨 

    /**/
    //배열 합치기 concat 
    const fruits2 = ['rice', 'water'];
    const newFruits = fruits.concat(fruits2);
    console.log(newFruits); //fruits+fruits

    /**/
    //검색할수있는 APIs
    console.clear();
    console.log(fruits);
    //indexOf 인덱스번호호출
    console.log(fruits.indexOf('peach')); //아이템의 인덱스번호가 몇번이지 ??

    //없는 아이템의 indexOf를 쓴 경우 -1로 값이 나옴
    console.log(fruits.indexOf('banana'));


    //includes는 아이템이 배열에 포함되어 있는지 true /false로 나옴
    console.log(fruits.includes('grape')); 

    //lastIndexOf
    fruits.push('apple'); //사과를 또 추가한 경우 
    console.log(fruits);
    console.log(fruits.lastIndexOf('apple')); //배열에서 지금 사과가 2개인데 가장 마지막에 있는 사과의 인덱스 값을 출력 ...!!

 </script>
</body>
</html>